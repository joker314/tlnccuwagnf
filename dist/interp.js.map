{"version":3,"sources":["interp.js"],"names":[],"mappings":"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","file":"interp.js","sourcesContent":["const C = require('./constants')\nconst lib = require('./lib')\nconst chalk = require('chalk')\nconst builtins = require('./builtins')\n\nif (!(console.group)) {\n  try {\n    require('console-group').install()\n  } catch(err) {\n    console.group = function(msg) {\n      console.log(chalk.cyan(`Group: ${msg}`))\n    }\n    console.groupEnd = function() {\n      console.log(chalk.cyan('Group end'))\n    }\n  }\n}\n\nexport async function evaluateExpression(expression, environment) {\n  // console.group(`Evaluate in environment ${environment}\\n`, expression)\n  const returnVal = await async function() {\n    if (expression[0] === C.COMMENT) {\n      return\n    } else if (expression instanceof Array &&\n               expression.every(e => e instanceof Array)) {\n      const ret = await evaluateEachExpression(expression, environment)\n      return ret\n    }\n\n    if (expression[0] === C.VARIABLE_IDENTIFIER && expression[1] === 'environment') {\n      return environment\n    } else if (expression[0] === C.FUNCTION_CALL) {\n      // Call a function: \"function(arg1, arg2, arg3...)\"\n\n      // Get the function and argument expressions from the expression list.\n      const fnExpression = expression[1]\n      const argExpressions = expression[2]\n\n      // Evaluate the function expression to get the actual function.\n      const fn = await evaluateExpression(fnExpression, environment)\n      const varName = fnExpression[1]\n\n      if (!(fn instanceof lib.LFunction)) {\n        throw new Error(`${chalk.cyan(varName)} is not a function`)\n      }\n\n      fn.argumentScope = environment\n      const args = argExpressions\n      const takingArgs = fn.paramaterList || []\n\n      // We need to discuss this... what's fn.builtin? This also should make sure\n      // that the called function is not a JS function, because you can't really\n      // get the number of paramaters from JS functions.\n      // if (args.length !== takingArgs.length && !fn.builtin) {\n      //   throw new Error(`Function ${chalk.cyan(varName)} expects ${chalk.bold(takingArgs.length)} arguments, was called with ${chalk.bold(args.length)}`)\n      // }\n\n      // Use lib.call to call the function with the evaluated arguments.\n      return await lib.call(fn, args)\n    } else if (expression[0] === C.VARIABLE_IDENTIFIER) {\n      // Get a variable: \"name\"\n\n      // Get the name from the expression list.\n      const name = expression[1]\n\n      // Return the variable's value, or, if the variable doesn't exist, throw an\n      // error.\n      if (environment.vars.hasOwnProperty(name)) {\n        const ret = environment.vars[name].value\n        return ret\n      } else {\n        throw new Error(`${chalk.cyan(name)} is not defined in ${Object.keys(environment.vars)}`)\n      }\n    } else if (expression[0] === C.VARIABLE_ASSIGN) {\n      // Set a variable to a value: \"name => value\"\n\n      // Get the name and value expression from the expression list.\n      const name = expression[1]\n      const valueExpression = expression[2]\n\n      // console.log(`Setting variable ${name}...`)\n\n      // Evaluate the value of the variable.\n      const value = await evaluateExpression(valueExpression, environment)\n\n      // console.log(`..value is ${value}`)\n\n      // Set the variable in the variables object to a new variable with the\n      // evaluated value.\n      environment.vars[name] = new lib.Variable(value)\n      return\n    } else if (expression[0] === C.VARIABLE_CHANGE) {\n      // Change a variable to a new value: \"name -> newValue\"\n\n      // Get the name and value expression from the expression list.\n      const name = expression[1]\n      const valueExpression = expression[2]\n\n      // Evaluate the new value of the variable.\n      const value = await evaluateExpression(valueExpression, environment)\n\n      // Change the value of the already defined variable.\n      environment.vars[name].value = value\n      return\n    } else if (expression[0] === C.FUNCTION_PRIM) {\n      // A function literal: \"[async] [(arg1, arg2, arg3...)] { code }\"\n\n      // Get the code and paramaters from the expression list.\n      const paramaters = expression[1]\n      const code = expression[2]\n      const isAsync = expression[3]\n\n      // Create the function using the given code.\n      const fn = new lib.LFunction(code)\n\n      // Set the scope variables for the function to a copy of the current\n      // variables.\n      fn.environment = new lib.LEnvironment()\n      fn.environment.parentEnvironment = environment\n      fn.environment.comment = 'Function environment'\n      fn.environment.addVars(environment.vars)\n\n      // Set the paramaters for the function to the paramaters taken from the\n      // expression list.\n      fn.setParamaters(paramaters)\n\n      fn.isAsynchronous = isAsync\n\n      // Return the function.\n      return fn\n    } else if (expression[0] === C.SHORTHAND_FUNCTION_PRIM) {\n      // >> OUTDATED CODE <<\n      const paramaters = expression[1]\n      const codeExpression = expression[2]\n      const fn = new lib.LFunction(codeExpression)\n      fn.isShorthand = true\n      fn.setScopeVariables(Object.assign({}, environment))\n      fn.setParamaters(paramaters)\n      return fn\n    } else if (expression[0] === C.STRING_PRIM) {\n      // String literal: \"contents\"\n\n      // Get string from expression list.\n      const string = expression[1]\n\n      // Convert string to a language-usable string, and return.\n      return lib.toLString(string)\n    } else if (expression[0] === C.BOOLEAN_PRIM) {\n      // Boolean literal: true/false\n\n      // Get boolean value from expression list.\n      const bool = expression[1]\n\n      // Convert boolean value to a language-usable boolean, and return.\n      return lib.toLBoolean(bool)\n    } else if (expression[0] === C.NUMBER_PRIM) {\n      // Number primitive: 1, 2, 3, 4, 7.25, -3, etc.\n\n      // Get number value from expression list.\n      const number = expression[1]\n\n      // Convert number value to a language-usable number, and return.\n      return lib.toLNumber(number)\n    } else if (expression[0] === C.SET_PROP_USING_IDENTIFIER) {\n      // Set a property of an object using an identifier literal:\n      // \"obj.key > value\"\n\n      // Get object expression, key, and value expression from expression list.\n      const objExpression = expression[1]\n      const key = expression[2]\n      const valueExpression = expression[3]\n\n      // Evaluate the object and value expressions.\n      const obj = await evaluateExpression(objExpression, environment)\n      const value = await evaluateExpression(valueExpression, environment)\n\n      // Use lib.set to set the property of the evaluated object.\n      lib.set(obj, key, value)\n\n      return\n    } else if (expression[0] === C.GET_PROP_USING_IDENTIFIER) {\n      // Get a property of an object using an identifier literal: \"obj.key\"\n\n      // Get object expression and key from the expression list.\n      const objExpression = expression[1]\n      const key = expression[2]\n\n      // Evaluate the object expression.\n      const obj = await evaluateExpression(objExpression, environment)\n\n      // Get the value from lib.get.\n      const value = lib.get(obj, key)\n\n      // Return the gotten value.\n      return value\n    } else {\n      throw new Error(`Invalid expression: ${chalk.cyan(expression[0])}`)\n    }\n  }()\n  // console.log(chalk.bold('Return value: ' + returnVal))\n  // console.groupEnd()\n  return returnVal\n}\n\nexport async function evaluateGetPropUsingIdentifier(variables, [_, objExpr, key]) {\n  let obj = await evaluateExpression(objExpr, variables)\n  return lib.get(obj, key)\n}\n\nexport async function evaluateEachExpression(expressions, environment) {\n  function checkBreak() {\n    let breakEnv = environment.breakToEnvironment\n    if (breakEnv !== null) {\n      if (breakEnv !== environment.parentEnvironment) {\n        environment.parentEnvironment.breakToEnvironment = breakEnv\n      }\n      return true\n    }\n    return false\n  }\n\n  if (checkBreak()) return []\n\n  let results = []\n  for (let expression of expressions) {\n    results.push(await evaluateExpression(expression, environment))\n    if (checkBreak()) break\n  }\n\n  return results\n}\n\nexport async function interp(ast, dir) {\n  if (ast) {\n    const environment = new lib.LEnvironment()\n\n    environment.comment = 'Master environment'\n\n    environment.addVars(builtins.makeBuiltins(dir))\n\n    let result = await evaluateEachExpression(ast, environment)\n\n    return { result, environment }\n  } else {\n    throw new Error('Haha, you didn\\'t pass me a tree!')\n  }\n}\n"],"sourceRoot":"/source/"}